name: deploy-prod

on:
  push:
    tags:
      - 'v*.*.*'
  workflow_dispatch:
    inputs:
      tag:
        description: 'Stable tag to deploy (e.g., v1.2.3)'
        required: false
        type: string

permissions:
  contents: read
  id-token: write
  issues: write
  security-events: write

concurrency:
  group: production-deploy
  cancel-in-progress: true

jobs:
  resolve-tag:
    name: Resolve deployment tag
    runs-on: ubuntu-latest
    outputs:
      stable_tag: ${{ steps.detect.outputs.tag }}
    steps:
      - name: Determine tag
        id: detect
        shell: bash
        run: |
          set -euo pipefail
          TAG_INPUT="${{ github.event.inputs.tag || '' }}"
          if [ -n "$TAG_INPUT" ]; then
            TAG="$TAG_INPUT"
          else
            TAG="${GITHUB_REF_NAME:-}"
          fi

          if [ -z "$TAG" ]; then
            echo "::error::No tag provided or detected."; exit 1
          fi
          if echo "$TAG" | grep -q -- '-rc\.'; then
            echo "::error::Production deployment requires a stable tag (got '$TAG')."; exit 1
          fi
          echo "Resolved tag: $TAG"
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"

  verify-images:
    name: Verify stable images
    needs: resolve-tag
    runs-on: ubuntu-latest
    outputs:
      analytics_image_uri: ${{ steps.verify.outputs.analytics_image_uri }}
      askbeacon_image_uri: ${{ steps.verify.outputs.askbeacon_image_uri }}
      registry: ${{ steps.verify.outputs.registry }}
    env:
      AWS_REGION: ${{ vars.AWS_REGION || 'ap-southeast-2' }}
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Check PROD images
        id: verify
        shell: bash
        run: |
          set -euo pipefail
          TAG="${{ needs.resolve-tag.outputs.stable_tag }}"
          ACCOUNT_ID=$(aws sts get-caller-identity --query 'Account' --output text)
          REG="${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"

          get_digest() {
            local repo="$1"
            aws ecr describe-images \
              --repository-name "$repo" \
              --image-ids imageTag="$TAG" \
              --query 'imageDetails[0].imageDigest' \
              --output text
          }

          ANALYTICS_REPO="sbeacon-prod-analytics-lambda-containers"
          ASKBEACON_REPO="sbeacon-prod-askbeacon-lambda-containers"

          ANALYTICS_DIGEST=$(get_digest "$ANALYTICS_REPO")
          ASKBEACON_DIGEST=$(get_digest "$ASKBEACON_REPO")

          if [ -z "$ANALYTICS_DIGEST" ] || [ "$ANALYTICS_DIGEST" = "None" ] || [ -z "$ASKBEACON_DIGEST" ] || [ "$ASKBEACON_DIGEST" = "None" ]; then
            echo "::error::Stable images not found in PROD ECR for tag '$TAG'. Run the promote workflow first.";
            exit 1
          fi

          echo "Analytics digest: $ANALYTICS_DIGEST"
          echo "AskBeacon digest: $ASKBEACON_DIGEST"

          echo "analytics_image_uri=${REG}/${ANALYTICS_REPO}@${ANALYTICS_DIGEST}" >> "$GITHUB_OUTPUT"
          echo "askbeacon_image_uri=${REG}/${ASKBEACON_REPO}@${ASKBEACON_DIGEST}" >> "$GITHUB_OUTPUT"
          echo "registry=${REG}" >> "$GITHUB_OUTPUT"

  terraform-plan:
    name: Terraform plan
    needs:
      - resolve-tag
      - verify-images
    runs-on: ubuntu-latest
    environment: prod
    outputs:
      apply_flag: 'true'
      destroy_flag: 'false'
      lambda_artifact: ${{ steps.lambda_artifact.outputs.lambda_artifact }}
    env:
      AWS_REGION: ${{ vars.AWS_REGION || 'ap-southeast-2' }}
      TF_WORKING_DIR: ${{ github.workspace }}/environments
      TARGET_WORKSPACE: prod
      TF_BACKEND_CONFIG: backend-prod.hcl
      TF_IN_AUTOMATION: true
      TF_INPUT: false
      TF_VAR_region: ${{ vars.AWS_REGION || 'ap-southeast-2' }}
      TF_VAR_beacon_admin_username: ${{ secrets.BEACON_ADMIN_USERNAME }}
      TF_VAR_beacon_admin_password: ${{ secrets.BEACON_ADMIN_PASSWORD }}
      TF_VAR_beacon_guest_username: ${{ secrets.BEACON_GUEST_USERNAME }}
      TF_VAR_beacon_guest_password: ${{ secrets.BEACON_GUEST_PASSWORD }}
      TF_VAR_azure_openai_api_key: ${{ secrets.AZURE_OPENAI_API_KEY }}
      TF_VAR_azure_openai_endpoint: ${{ secrets.AZURE_OPENAI_ENDPOINT }}
      TF_VAR_azure_openai_api_version: ${{ secrets.AZURE_OPENAI_API_VERSION }}
      TF_VAR_azure_openai_chat_deployment_name: ${{ secrets.AZURE_OPENAI_CHAT_DEPLOYMENT_NAME }}
      TF_VAR_openai_api_key: ${{ secrets.OPENAI_API_KEY }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Normalize workspace name for assets
        run: |
          set -euo pipefail
          safe=$(printf '%s' "${TARGET_WORKSPACE}" | tr '[:upper:]' '[:lower:]')
          safe=$(printf '%s' "${safe}" | sed -E 's/[^a-z0-9._-]+/-/g')
          safe=$(printf '%s' "${safe}" | sed -E 's/^-+//; s/-+$//; s/-{2,}/-/g')
          if [ -z "${safe}" ]; then
            echo "::error::Normalized workspace name is empty." >&2
            exit 1
          fi
          echo "WORKSPACE_SAFE=${safe}" >> "$GITHUB_ENV"
          echo "LAMBDA_BUILD_ARTIFACT=lambda-build-plans-${safe}-${GITHUB_RUN_ID}" >> "$GITHUB_ENV"

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install build toolchain
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential autoconf automake libtool pkg-config zlib1g-dev libcurl4-openssl-dev libbz2-dev liblzma-dev

      - name: Run init script
        run: |
          set -euo pipefail
          chmod +x ./init.sh
          ./init.sh

      - name: Prepare build directories
        run: mkdir -p builds

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.9.4

      - name: Cache Terraform plugins & .terraform
        uses: actions/cache@v4
        with:
          path: |
            ~/.terraform.d/plugin-cache
            ${{ env.TF_WORKING_DIR }}/.terraform
          key: ${{ runner.os }}-tf-${{ hashFiles('**/*.tf','**/*.tfvars','**/*.hcl') }}
          restore-keys: ${{ runner.os }}-tf-

      - name: Terraform Init
        run: terraform -chdir=${{ env.TF_WORKING_DIR }} init -input=false -upgrade -backend-config=${{ env.TF_BACKEND_CONFIG }}

      - name: Select Terraform Workspace
        run: terraform -chdir=${{ env.TF_WORKING_DIR }} workspace select ${{ env.TARGET_WORKSPACE }} || terraform -chdir=${{ env.TF_WORKING_DIR }} workspace new ${{ env.TARGET_WORKSPACE }}

      - name: Export analytics image URI
        run: echo "TF_VAR_analytics_lambda_image_uri=${{ needs.verify-images.outputs.analytics_image_uri }}" >> $GITHUB_ENV

      - name: Export askbeacon image URI
        run: echo "TF_VAR_askbeacon_lambda_image_uri=${{ needs.verify-images.outputs.askbeacon_image_uri }}" >> $GITHUB_ENV

      - name: Terraform Validate
        run: terraform -chdir=${{ env.TF_WORKING_DIR }} validate

      - name: IaC scan (Terraform) with Trivy config
        id: trivy_iac
        continue-on-error: true
        uses: aquasecurity/trivy-action@0.24.0
        with:
          scan-type: 'config'
          scan-ref: './environments'
          format: 'table'
          output: 'trivy-iac.txt'
          severity: 'CRITICAL,HIGH'
          exit-code: '0'
          timeout: '5m'

      - name: Attach IaC scan to summary
        if: always() && steps.trivy_iac.outcome != 'skipped'
        run: |
          echo '### Trivy IaC (Terraform) report' >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          tail -n 200 trivy-iac.txt >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

      - name: Upload IaC report artifact
        if: always() && steps.trivy_iac.outcome != 'skipped'
        uses: actions/upload-artifact@v4
        with:
          name: trivy-iac-${{ github.run_id }}
          path: trivy-iac.txt

      - name: Gate IaC scan
        if: steps.trivy_iac.outcome == 'failure'
        run: |
          echo "::error::Trivy IaC scan found HIGH/CRITICAL."
          exit 1

      - name: Terraform Plan
        id: terraform_plan
        run: |
          terraform -chdir=${{ env.TF_WORKING_DIR }} plan -input=false -lock-timeout=10m -out=tfplan
          terraform -chdir=${{ env.TF_WORKING_DIR }} show -no-color tfplan > ${{ env.TF_WORKING_DIR }}/tfplan.txt

      - name: Upload lambda build plans
        if: steps.terraform_plan.outcome == 'success'
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.LAMBDA_BUILD_ARTIFACT }}
          path: builds

      - name: Upload plan (text)
        uses: actions/upload-artifact@v4
        with:
          name: prod-terraform-plan-${{ github.run_id }}
          path: ${{ env.TF_WORKING_DIR }}/tfplan.txt

      - name: Upload plan (binary)
        uses: actions/upload-artifact@v4
        with:
          name: prod-tfplan-binary-${{ github.run_id }}
          path: ${{ env.TF_WORKING_DIR }}/tfplan

      - name: Record lambda artifact name
        id: lambda_artifact
        run: |
          echo "lambda_artifact=${LAMBDA_BUILD_ARTIFACT}" >> "$GITHUB_OUTPUT"

  manual-approval:
    name: Await approval
    needs:
      - terraform-plan
      - resolve-tag
    runs-on: ubuntu-latest
    steps:
      - uses: trstringer/manual-approval@v1
        with:
          approvers: ${{ github.actor }}
          secret: ${{ secrets.GITHUB_TOKEN }}
          issue-title: 'Prod apply approval for ${{ needs.resolve-tag.outputs.stable_tag }}'
          issue-body: 'Confirm terraform apply for production tag `${{ needs.resolve-tag.outputs.stable_tag }}`'
          exclude-workflow-initiator-as-approver: false
          fail-on-denial: true

  terraform-apply:
    name: Terraform apply
    needs:
      - terraform-plan
      - manual-approval
    runs-on: ubuntu-latest
    environment: prod
    env:
      AWS_REGION: ${{ vars.AWS_REGION || 'ap-southeast-2' }}
      TF_WORKING_DIR: ${{ github.workspace }}/environments
      TARGET_WORKSPACE: prod
      TF_BACKEND_CONFIG: backend-prod.hcl
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Normalize workspace name for assets
        run: |
          set -euo pipefail
          safe=$(printf '%s' "${TARGET_WORKSPACE}" | tr '[:upper:]' '[:lower:]')
          safe=$(printf '%s' "${safe}" | sed -E 's/[^a-z0-9._-]+/-/g')
          safe=$(printf '%s' "${safe}" | sed -E 's/^-+//; s/-+$//; s/-{2,}/-/g')
          if [ -z "${safe}" ]; then
            echo "::error::Normalized workspace name is empty." >&2
            exit 1
          fi
          echo "WORKSPACE_SAFE=${safe}" >> "$GITHUB_ENV"

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install build toolchain
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential autoconf automake libtool pkg-config zlib1g-dev libcurl4-openssl-dev libbz2-dev liblzma-dev

      - name: Run init script
        run: |
          set -euo pipefail
          chmod +x ./init.sh
          ./init.sh

      - name: Prepare build directories
        run: mkdir -p builds

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.9.4

      - name: Cache Terraform plugins & .terraform
        uses: actions/cache@v4
        with:
          path: |
            ~/.terraform.d/plugin-cache
            ${{ env.TF_WORKING_DIR }}/.terraform
          key: ${{ runner.os }}-tf-${{ hashFiles('**/*.tf','**/*.tfvars','**/*.hcl') }}
          restore-keys: ${{ runner.os }}-tf-

      - name: Download plan (binary)
        uses: actions/download-artifact@v4
        with:
          name: prod-tfplan-binary-${{ github.run_id }}
          path: ${{ env.TF_WORKING_DIR }}

      - name: Download lambda build plans
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.terraform-plan.outputs.lambda_artifact }}
          path: .

      - name: Terraform Init
        run: terraform -chdir=${{ env.TF_WORKING_DIR }} init -input=false -upgrade -backend-config=${{ env.TF_BACKEND_CONFIG }}

      - name: Select Terraform Workspace
        run: terraform -chdir=${{ env.TF_WORKING_DIR }} workspace select ${{ env.TARGET_WORKSPACE }} || terraform -chdir=${{ env.TF_WORKING_DIR }} workspace new ${{ env.TARGET_WORKSPACE }}

      - name: Terraform Apply
        run: terraform -chdir=${{ env.TF_WORKING_DIR }} apply -input=false -lock-timeout=10m -auto-approve tfplan

      - name: Publish API URL
        shell: bash
        run: |
          set -euo pipefail
          url=$(terraform -chdir=${{ env.TF_WORKING_DIR }} output -raw api_url)
          if [ -z "${url}" ]; then
            echo "::error::terraform output 'api_url' is empty."; exit 1
          fi
          echo "Discovered API URL: ${url}"
          echo "SMOKE_URL=${url}" >> $GITHUB_ENV
          aws ssm put-parameter \
            --name "/serverless-beacon/${{ env.TARGET_WORKSPACE }}/api_url" \
            --value "${url}" \
            --type String \
            --overwrite \
            --region "${{ env.AWS_REGION }}"

      - name: Clean up plan files
        if: always()
        run: rm -f ${{ env.TF_WORKING_DIR }}/tfplan ${{ env.TF_WORKING_DIR }}/tfplan.txt

  smoke-tests:
    name: Smoke tests
    needs:
      - terraform-plan
      - terraform-apply
    runs-on: ubuntu-latest
    environment: prod
    env:
      AWS_REGION: ${{ vars.AWS_REGION || 'ap-southeast-2' }}
      TF_WORKING_DIR: ${{ github.workspace }}/environments
      TARGET_WORKSPACE: prod
      TF_BACKEND_CONFIG: backend-prod.hcl
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.9.4

      - name: Terraform Init
        run: terraform -chdir=${{ env.TF_WORKING_DIR }} init -input=false -upgrade -backend-config=${{ env.TF_BACKEND_CONFIG }}

      - name: Select Terraform Workspace
        run: terraform -chdir=${{ env.TF_WORKING_DIR }} workspace select ${{ env.TARGET_WORKSPACE }} || terraform -chdir=${{ env.TF_WORKING_DIR }} workspace new ${{ env.TARGET_WORKSPACE }}

      - name: Publish API URL
        shell: bash
        run: |
          set -euo pipefail
          url=$(terraform -chdir=${{ env.TF_WORKING_DIR }} output -raw api_url 2>/dev/null || echo "")
          if [ -z "${url}" ]; then
            echo "::error::terraform output 'api_url' is empty or missing.";
            terraform -chdir=${{ env.TF_WORKING_DIR }} output 2>&1 || true
            exit 1
          fi
          echo "Discovered API URL: ${url}"
          echo "SMOKE_URL=${url}" >> $GITHUB_ENV

      - name: Acquire smoke token
        id: smoke_token
        shell: bash
        run: |
          set -euo pipefail
          token=""
          login_cmd=$(terraform -chdir=${{ env.TF_WORKING_DIR }} output -raw admin_login_command 2>/dev/null || echo "N/A")
          if [ "${login_cmd}" != "N/A" ] && [ -n "${login_cmd}" ]; then
            token=$(eval "${login_cmd}" 2>/dev/null | tr -d '"' || true)
          fi
          if [ -z "${token}" ]; then
            echo "::notice::No bearer token acquired; protected endpoints will be reported as skipped."
          fi
          echo "bearer=${token}" >> "$GITHUB_OUTPUT"

      - name: API smoke tests
        shell: bash
        run: |
          set -euo pipefail
          REPORT_JSON="smoke_report.json"
          REPORT_MD="smoke_report.md"
          python scripts/api_smoke_report.py \
            --base-url "${SMOKE_URL}" \
            --paths-file scripts/smoke_paths.txt \
            --bearer-token "${{ steps.smoke_token.outputs.bearer }}" \
            --retries 3 \
            --backoff 2 \
            --timeout 10 \
            --report-json "${REPORT_JSON}" \
            --report-md "${REPORT_MD}"
          if [ -f "${REPORT_MD}" ]; then
            cat "${REPORT_MD}" >> "$GITHUB_STEP_SUMMARY"
          fi
          mkdir -p reports
          mv "${REPORT_JSON}" "${REPORT_MD}" reports/

      - name: Upload smoke reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: prod-smoke-${{ github.run_id }}
          path: reports/

  post-deploy:
    name: Post deployment summary
    needs:
      - verify-images
      - terraform-apply
      - smoke-tests
      - resolve-tag
    runs-on: ubuntu-latest
    steps:
      - name: Summarize deployment
        run: |
          echo "### Deployed to **prod**" >> $GITHUB_STEP_SUMMARY
          echo "- Tag: \\`${{ needs.resolve-tag.outputs.stable_tag }}\\`" >> $GITHUB_STEP_SUMMARY
          echo "- Registry: \\`${{ needs.verify-images.outputs.registry }}\\`" >> $GITHUB_STEP_SUMMARY
          echo "- Analytics image: \\`${{ needs.verify-images.outputs.analytics_image_uri }}\\`" >> $GITHUB_STEP_SUMMARY
          echo "- AskBeacon image: \\`${{ needs.verify-images.outputs.askbeacon_image_uri }}\\`" >> $GITHUB_STEP_SUMMARY

  no-deploy:
    name: Skip deployment
    needs: resolve-tag
    if: needs.resolve-tag.outputs.stable_tag == ''
    runs-on: ubuntu-latest
    steps:
      - name: Skipped
        run: echo "No stable tag resolved; skipping production deployment."

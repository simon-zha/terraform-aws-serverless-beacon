# .github/workflows/health-check.yml
name: API Health Check
on:
  workflow_dispatch:  # Trigger 1: Manual trigger (supports custom inputs)
    inputs:
      environment:
        description: "Environment to check (dev/staging/prod/all)"
        required: false
        default: "all"  # Default: check all environments
      expected_status:
        description: "Expected HTTP status code"
        required: false
        default: "200"  # Default
      retries:
        description: "Maximum retry attempts"
        required: false
        default: "6"  # Default
      timeout:
        description: "Per-request timeout in seconds"
        required: false
        default: "8"  # Default
      backoff:
        description: "Exponential backoff multiplier"
        required: false
        default: "2"  # Default
  schedule:  # Trigger 2: Scheduled trigger
    - cron: "20 * * * *"  # Run at 20th minute of every hour

# Permission configuration: GitHub permissions required for the workflow
permissions:
  contents: read  # Read repository contents
  actions: read  # Read workflow information
  id-token: write  # Write identity token (for AWS authentication)
  issues: write  # Create/comment on GitHub Issues

jobs:
  health-check:
    name: Check ${{ matrix.environment_name }} API
    runs-on: ubuntu-latest  # Run environment: Latest Ubuntu
    strategy:
      fail-fast: false  # Non-fast fail (one environment failure won't stop others)
      matrix:
        include:  # Multi-environment matrix configuration (environment-specific params)
          - environment_name: dev  # Env name: Development
            github_environment: dev  # Associated GitHub environment
            workspace: dev  # Corresponding Terraform workspace
            ssm_parameter: /serverless-beacon/dev/api_url  # AWS SSM parameter for API URL
          - environment_name: staging
            github_environment: staging
            workspace: staging
            ssm_parameter: /serverless-beacon/staging/api_url
          - environment_name: prod
            github_environment: prod
            workspace: prod
            ssm_parameter: /serverless-beacon/prod/api_url
    environment: ${{ matrix.github_environment }}  # Bind to corresponding GitHub environment (pre-configured)
    env:
      ENV_NAME: ${{ matrix.environment_name }}  # Environment name (from matrix)
      WORKSPACE: ${{ matrix.workspace }}  # Workspace name
      SSM_PARAMETER: ${{ matrix.ssm_parameter }}  # SSM parameter name
      API_URL: ""  # Initialize API URL variable (fetched from SSM later)
      # Env var: Use manual input if available, default to 200
      EXPECTED_STATUS: ${{ (github.event_name == 'workflow_dispatch' && github.event.inputs.expected_status) || '200' }}
      # Env var: Use manual input if available, default to 6 retries
      RETRIES: ${{ (github.event_name == 'workflow_dispatch' && github.event.inputs.retries) || '6' }}
      # Env var: Use manual input if available, default to 8s timeout
      TIMEOUT: ${{ (github.event_name == 'workflow_dispatch' && github.event.inputs.timeout) || '8' }}
      # Env var: Use manual input if available, default backoff 2
      BACKOFF: ${{ (github.event_name == 'workflow_dispatch' && github.event.inputs.backoff) || '2' }}
      AWS_REGION: ${{ vars.AWS_REGION || 'ap-southeast-2' }}  # AWS region (repo var first, default to Sydney)
      # Cognito authentication variables (from GitHub Secrets, optional)
      COGNITO_USER_POOL_ID: ${{ secrets.COGNITO_USER_POOL_ID || '' }}
      COGNITO_APP_CLIENT_ID: ${{ secrets.COGNITO_APP_CLIENT_ID || '' }}
      COGNITO_USERNAME: ${{ secrets.BEACON_GUEST_USERNAME || secrets.BEACON_ADMIN_USERNAME || '' }}
      COGNITO_PASSWORD: ${{ secrets.BEACON_GUEST_PASSWORD || secrets.BEACON_ADMIN_PASSWORD || '' }}
      # Run condition: Scheduled = run all; Manual = run selected envs
      SHOULD_RUN: ${{ github.event_name != 'workflow_dispatch' || github.event.inputs.environment == 'all' || github.event.inputs.environment == matrix.environment_name }}
    steps:
      # Step 1: Skip unselected environments (manual trigger only)
      - name: Report skip
        if: env.SHOULD_RUN != 'true'
        run: echo "Skipping ${ENV_NAME} health check because it was not selected."

      # Step 2: Validate Cognito configuration (if authentication is enabled)
      - name: Validate Cognito configuration
        if: env.SHOULD_RUN == 'true'
        run: |
          # Validate Cognito parameter completeness (User Pool ID and Client ID must exist together)
          if [ -n "${COGNITO_USER_POOL_ID}" ] && [ -z "${COGNITO_APP_CLIENT_ID}" ]; then
            echo "::error::COGNITO_USER_POOL_ID is set but COGNITO_APP_CLIENT_ID is missing."
            exit 1
          fi
          if [ -n "${COGNITO_APP_CLIENT_ID}" ] && [ -z "${COGNITO_USER_POOL_ID}" ]; then
            echo "::error::COGNITO_APP_CLIENT_ID is set but COGNITO_USER_POOL_ID is missing."
            exit 1
          fi
          # Require username/password if Cognito is enabled
          if [ -n "${COGNITO_USER_POOL_ID}" ] || [ -n "${COGNITO_APP_CLIENT_ID}" ]; then
            if [ -z "${COGNITO_USERNAME}" ] || [ -z "${COGNITO_PASSWORD}" ]; then
              echo "::error::Cognito authentication requested but username/password secrets are missing."
              exit 1
            fi
          fi

      # Step 3: Check out repository (to access health check script)
      - name: Checkout repository
        if: env.SHOULD_RUN == 'true'
        uses: actions/checkout@v4

      # Step 4: Configure AWS credentials (for SSM parameter and Cognito token)
      - name: Configure AWS credentials
        if: env.SHOULD_RUN == 'true'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}  # AWS role ARN from Secrets
          aws-region: ${{ env.AWS_REGION }}  # Use specified AWS region

      # Step 5: Resolve API URL from AWS SSM Parameter Store
      - name: Resolve API URL
        if: env.SHOULD_RUN == 'true'
        run: |
          set -euo pipefail  # Strict script mode (exit on error)
          url="${API_URL}"
          if [ -z "${url}" ]; then
            tmp_err="$(mktemp)"
            # Fetch API URL from SSM (with decryption)
            url=$(aws ssm get-parameter \
              --name "${SSM_PARAMETER}" \
              --with-decryption \
              --region "${AWS_REGION}" \
              --query 'Parameter.Value' \
              --output text 2>"${tmp_err}" || true)
            # Handle fetch failure
            if [ "${url}" = "None" ]; then
              url=""
            fi
            if [ -z "${url}" ]; then
              echo "::error::Unable to resolve API URL from parameter ${SSM_PARAMETER}."
              if [ -s "${tmp_err}" ]; then
                echo "--- aws ssm get-parameter output ---"
                cat "${tmp_err}"
                echo "------------------------------------"
              fi
              rm -f "${tmp_err}"
              exit 1
            fi
            rm -f "${tmp_err}"
          fi
          echo "Resolved API URL: ${url}"
          echo "API_URL=${url}" >> $GITHUB_ENV  # Store in env var for later use

      # Step 6: Obtain Cognito identity token (if Cognito is configured)
      - name: Obtain Cognito token
        if: env.SHOULD_RUN == 'true' && env.COGNITO_USER_POOL_ID != '' && env.COGNITO_APP_CLIENT_ID != '' && env.COGNITO_USERNAME != '' && env.COGNITO_PASSWORD != ''
        id: cognito  # Step ID (for referencing token in later steps)
        shell: bash
        run: |
          set -euo pipefail
          # Call AWS Cognito API to get authentication token
          response=$(aws cognito-idp admin-initiate-auth \
            --user-pool-id "${COGNITO_USER_POOL_ID}" \
            --region "${AWS_REGION}" \
            --client-id "${COGNITO_APP_CLIENT_ID}" \
            --auth-flow ADMIN_USER_PASSWORD_AUTH \
            --auth-parameters USERNAME="${COGNITO_USERNAME}",PASSWORD="${COGNITO_PASSWORD}")
          # Parse IdToken (using jq tool)
          token=$(echo "${response}" | jq -r '.AuthenticationResult.IdToken // empty')
          if [ -z "${token}" ]; then
            echo "::error::Failed to obtain Cognito IdToken."
            exit 1
          fi
          echo "token=${token}" >> "$GITHUB_OUTPUT"  # Output to step results
          echo "BEARER_TOKEN=${token}" >> "$GITHUB_ENV"  # Store in env var

      # Step 7: Set up Python environment (to run health check script)
      - name: Set up Python
        if: env.SHOULD_RUN == 'true'
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"  # Specify Python version

      # Step 8: Run API health check
      - name: Run health check
        if: env.SHOULD_RUN == 'true'
        id: health  # Step ID (to check outcome later)
        continue-on-error: true  # Allow failure (handled separately)
        run: |
          set -euo pipefail
          EXTRA_ARGS=()
          # Add Bearer token to args if available
          if [ -n "${BEARER_TOKEN:-}" ]; then
            EXTRA_ARGS+=(--bearer-token "${BEARER_TOKEN}")
          fi
          # Run Python health check script (pass all config params)
          python scripts/health_check.py \
            --url "${API_URL}" \
            --expected-status "${EXPECTED_STATUS}" \
            --retries "${RETRIES}" \
            --timeout "${TIMEOUT}" \
            --backoff "${BACKOFF}" \
            "${EXTRA_ARGS[@]}"

      # Step 9: Handle health check failure(create/update GitHub Issue)
      - name: Handle failure
        if: env.SHOULD_RUN == 'true' && steps.health.outcome == 'failure'
        uses: actions/github-script@v7  # Use GitHub Script action to manipulate Issues
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}  # GitHub built-in token (for repo operations)
          script: |
            const envName = '${{ matrix.environment_name }}';
            const apiUrl = process.env.API_URL;
            const runUrl = `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`;
            const title = `API Health Check failed: ${envName}`;  # Issue title
            # Issue body (includes env, URL, workflow link)
            const body = [
              `Environment: **${envName}**`,
              `URL: ${apiUrl}`,
              `Workflow run: ${runUrl}`,
              '',
              'Please verify API availability.'
            ].join('\n');
            // Query open Issues in the repo (filtered by label and title)
            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              per_page: 100,
              labels: 'health-check'
            });
            const existing = issues.find(issue => issue.title === title);
            if (existing) {
              // Add comment to existing Issue if it exists
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: existing.number,
                body: `Health check failed again. Details: ${runUrl}`
              });
            } else {
              // Create new Issue if it doesn't exist (with labels)
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title,
                body,
                labels: ['health-check','automated']
              });
            }
            core.setFailed(`Health check failed for ${envName}`);  # Mark workflow as failed

      # Step 10: Append result to workflow summary (success/failure)
      - name: Append result to summary
        if: env.SHOULD_RUN == 'true'
        run: |
          if [ "${{ steps.health.outcome }}" = "success" ]; then
            status="[PASS]"
          else
            status="[FAIL]"
          fi
          {
            echo "### ${status} - ${ENV_NAME}"
            echo "- URL: ${API_URL}"
            echo "- Run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          } >> "$GITHUB_STEP_SUMMARY"  # Write to GitHub step summary (UI display)

      # Step 11: Append skip status to workflow summary
      - name: Append skip summary
        if: env.SHOULD_RUN != 'true'
        run: |
          {
            echo "### [SKIP] - ${ENV_NAME}"
            echo "- Reason: not selected for this execution."
          } >> "$GITHUB_STEP_SUMMARY"

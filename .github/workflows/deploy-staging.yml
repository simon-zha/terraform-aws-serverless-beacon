# .github/workflows/staging-release.yml
name: Staging Tag & GitHub Release

on:
  pull_request:
    branches: ['release', 'release/**']
    types: [closed]
# Staging and Hotfix branch only allow merge
# on:
#   push:
#     branches:
#       - 'release/**'
#       - 'hotfix/**'
# jobs:
#   terraform_deploy_staging:
#     runs-on: ubuntu-latest
#     environment: staging
#     steps:
#     - name: Checkout Code
#       uses: actions/checkout@v4
#     # in progress
#     - name: Configure AWS Credentials 
#     - name: Setup Terraform
#       uses: hashicorp/setup-terraform@v3
#     - name: Docker build
#     - name: Docker push
#     - name: Deploy to dev environment
#
#     # Example: capture and upload api_url after successful terraform apply
#     # Uncomment and adapt below to enable automatic post-deploy artifact upload
#     #      - name: Capture API URL (post-deploy)
#     #        if: env.TF_APPLY_FLAG == 'true'
#     #        run: |
#     #          set -euo pipefail
#     #          echo "Retrieving api_url from terraform outputs..."
#     #          if terraform -chdir=${{ env.TF_WORKING_DIR }} output -raw api_url > post_deploy_info.txt 2>/dev/null; then
#     #            echo "Captured api_url"
#     #          else
#     #            echo "Falling back to json output parsing"
#     #            terraform -chdir=${{ env.TF_WORKING_DIR }} output -json api_url | python -c "import sys, json; print(json.load(sys.stdin))" > post_deploy_info.txt
#     #          fi
#     #
#     #      - name: Upload post-deploy info
#     #        if: env.TF_APPLY_FLAG == 'true'
#     #        uses: actions/upload-artifact@v4
#     #        with:
#     #          name: post-deploy-info-${{ github.run_id }}
#     #          path: post_deploy_info.txt

permissions:
  contents: write

concurrency:
  group: staging-release
  cancel-in-progress: true

jobs:
  tag_and_release:
    if: >
      github.event.pull_request.merged == true &&
      (github.event.pull_request.base.ref == 'release' || startsWith(github.event.pull_request.base.ref, 'release/')) &&
      github.event.pull_request.head.ref == 'develop'
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Resolve tag and release type (from PR description)
        id: ver
        shell: bash
        run: |
          set -euo pipefail
          git fetch --tags --force

          # Read PR description
          BODY="${{ github.event.pull_request.body || '' }}"

          # Optional overrides in PR description (case-insensitive, one per line):
          #   tag: v1.2.3-rc.4   or   tag: v1.2.3
          #   release-type: prerelease   or   release-type: stable
          TAG_OVERRIDE="$(printf '%s\n' "$BODY" | sed -nE 's/.*tag:[[:space:]]*(v[0-9]+\.[0-9]+\.[0-9]+(-rc\.[0-9]+)?).*/\1/ip' | head -1)"
          TYPE_OVERRIDE="$(printf '%s\n' "$BODY" | sed -nE 's/.*release-type:[[:space:]]*(prerelease|stable).*/\1/ip' | tr '[:upper:]' '[:lower:]' | head -1)"

          if [ -n "$TAG_OVERRIDE" ]; then
            if git rev-parse -q --verify "refs/tags/$TAG_OVERRIDE" >/dev/null; then
              echo "::error::Tag '$TAG_OVERRIDE' already exists."; exit 1
            fi
            TAG="$TAG_OVERRIDE"
          else
            # Auto-generate next rc from latest stable vX.Y.Z
            LATEST="$(git tag --list 'v[0-9]*' | grep -v -- '-rc\.' | sort -V | tail -1)"
            [ -z "$LATEST" ] && LATEST="v0.0.0"
            BASE="${LATEST%%-*}"
            IFS='.' read -r MA MI PA <<<"${BASE#v}"
            TITLE="${{ github.event.pull_request.title || '' }}"
            if echo "$TITLE" | grep -qiE 'BREAKING CHANGE|feat!'; then BUMP=major;
            elif echo "$TITLE" | grep -qiE '^feat(\(|: )'; then BUMP=minor; else BUMP=patch; fi
            case "$BUMP" in
              major) MA=$((MA+1)); MI=0; PA=0;;
              minor) MI=$((MI+1)); PA=0;;
              patch) PA=$((PA+1));;
            esac
            BASE="v${MA}.${MI}.${PA}"
            LAST_RC=$(git tag -l "${BASE}-rc.*" | sed -E 's/.*-rc\.([0-9]+)$/\1/' | sort -n | tail -1)
            N=$(( ${LAST_RC:-0} + 1 ))
            TAG="${BASE}-rc.${N}"
          fi

          if [ -n "$TYPE_OVERRIDE" ]; then
            case "$TYPE_OVERRIDE" in
              prerelease) PRERELEASE=true ;;
              stable)     PRERELEASE=false ;;
              *) echo "::error::Invalid release-type override."; exit 1 ;;
            esac
            if [ "$PRERELEASE" = false ] && echo "$TAG" | grep -q -- '-rc\.'; then
              echo "::error::release-type=stable requires a non-rc tag (e.g., v1.2.3)."; exit 1
            fi
            if [ "$PRERELEASE" = true ] && ! echo "$TAG" | grep -q -- '-rc\.'; then
              echo "::error::release-type=prerelease requires an rc tag (e.g., v1.2.3-rc.1)."; exit 1
            fi
          else
            if echo "$TAG" | grep -q -- '-rc\.'; then PRERELEASE=true; else PRERELEASE=false; fi
          fi

          echo "tag=$TAG" >> "$GITHUB_OUTPUT"
          echo "prerelease=$PRERELEASE" >> "$GITHUB_OUTPUT"

      - name: Create and push tag
        run: |
          git config user.name  "${GITHUB_ACTOR}"
          git config user.email "${GITHUB_ACTOR}@users.noreply.github.com"
          git tag -a "${{ steps.ver.outputs.tag }}" -m "release: ${{ github.sha }} via PR #${{ github.event.pull_request.number }}"
          git push origin "${{ steps.ver.outputs.tag }}"

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name:  ${{ steps.ver.outputs.tag }}
          name:      ${{ steps.ver.outputs.tag }}
          prerelease: ${{ steps.ver.outputs.prerelease }}
          target_commitish: ${{ github.sha }}
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          

